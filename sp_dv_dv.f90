!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.14 (r7259) - 18 Jan 2019 09:34
!
!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.14 (r7259) - 18 Jan 2019 09:34
!
MODULE SP_DIFFV_DIFFV
  USE DIFFSIZES
  USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
  IMPLICIT NONE

CONTAINS
!
! %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
!    FUNCTION InverseMillsRatio ( x, u )
!    !
!    ! Calcola 
!    !
!    ! phi(x)/[1-Phi(x)]       se u = .TRUE.
!    ! phi(x)/Phi(x)           se u = .FALSE.
!    !
!    ! NB: C'è un errore nel manuale online dell'Intel Fortran 
!    ! alla voce ERFC_SCALED:
!    ! la frazione 2/sqrt(x) dovrebbe essere 2/sqrt(pi)
!    !
!    REAL(8), INTENT(IN) :: x
!    LOGICAL, INTENT(IN) :: u
!    !
!    REAL(8) :: z
!    !
!    REAL(8) :: InverseMillsRatio
!    !
!    REAL(8), PARAMETER :: invsqrt2 = 0.707106781186547524400844362105d0
!    REAL(8), PARAMETER :: sqrtpiover2 = 1.25331413731550025120788264241d0
!    !
!    IF (u) z = invsqrt2*x
!    IF (.NOT.(u)) z = -invsqrt2*x
!    InverseMillsRatio = 1.d0/(sqrtpiover2*ERFC_SCALED(z))
!    !
!    END FUNCTION InverseMillsRatio
!
! %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
!    SUBROUTINE comp_eigenvals_rsym ( task, need_eigenvectors, n, mat, &
!        mat_eigvect, eigval, flag_error)
!    !
!    ! Computes all eigenvalues and, optionally, eigenvectors of a
!    ! real (n x n) symmetric matrix mat
!    ! Eigenvalues are returned in ascending order
!    !
!    IMPLICIT NONE
!    !
!    ! Declaring dummy variables
!    !
!    CHARACTER(len=30), INTENT(IN) :: task
!    LOGICAL, INTENT(IN) :: need_eigenvectors
!    INTEGER, INTENT(IN) :: n
!    REAL(8), INTENT(IN) :: mat(n,n)
!    REAL(8), INTENT(OUT) :: mat_eigvect(n,n)
!    REAL(8), INTENT(OUT) :: eigval(n)
!    LOGICAL, INTENT(OUT) :: flag_error
!    !
!    ! Declaring local variables
!    !
!    CHARACTER(LEN=1) :: jobz
!    INTEGER :: lwork
!    REAL(8) :: work(10*n)
!    INTEGER :: info
!    !
!    ! Beginning execution
!    !
!    IF (need_eigenvectors) jobz = 'V'
!    IF (.NOT.(need_eigenvectors)) jobz = 'N'
!    mat_eigvect = mat
!    lwork = 10*n
!    CALL dsyev(jobz,'U',n,mat_eigvect,n,eigval,work,lwork,info)
!    IF (info .NE. 0) THEN
!        WRITE(*,1) task
!1       FORMAT('Problem with dsyev in task ', A30)
!        PRINT*, 'info = ', info
!        PAUSE 
!        flag_error = .TRUE.
!        RETURN
!    END IF
!    !
!    ! Ending execution and returning control
!    !
!    END SUBROUTINE comp_eigenvals_rsym
!
! %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
!    SUBROUTINE solve_lin_sys ( task, n, mat1, m, mat2, matsol, flag_error )
!    !
!    ! Computes the solution to a real system of linear equations
!    ! mat1 * X = mat2,
!    ! where mat1 is an (n x n) matrix and X and mat2 are (n x m)matrices.
!    !
!    IMPLICIT NONE
!    !
!    ! Declaring dummy variables
!    !
!    CHARACTER(len=30), INTENT(IN) :: task
!    INTEGER, INTENT(IN) :: n
!    REAL(8), INTENT(IN) :: mat1(n,n)
!    INTEGER, INTENT(IN) :: m
!    REAL(8), INTENT(IN) :: mat2(n,m)
!    REAL(8), INTENT(OUT) :: matsol(n,m)
!    LOGICAL, INTENT(OUT) :: flag_error
!    !
!    ! Declaring local variables
!    !
!    REAL(8) :: tmp(n,n)
!    INTEGER :: ipiv(n), info
!    !
!    ! Beginning execution
!    !
!    tmp = mat1
!    matsol = mat2
!    CALL dgesv(n,m,tmp,n,ipiv,matsol,n,info)
!    IF (info .NE. 0) THEN
!        WRITE(*,1) task
!1       FORMAT('Problem with dgesv in task ', A30)
!        PRINT*, 'info = ', info
!        PAUSE 
!        flag_error = .TRUE.
!        RETURN
!    END IF
!    !
!    ! Ending execution and returning control
!    !
!    END SUBROUTINE solve_lin_sys
!
! %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
!    SUBROUTINE dbrent ( fct, ax, bx, cx, tol, itmax, xmin, fmin )
!    !
!    ! Based on NR77, 10.3, p. 400-1
!    ! Given a function f and its derivative function df, and given 
!    ! a bracketing triplet of abscissas ax, bx, cx [such that bx is 
!    ! between ax and cx, and f(bx) is less than both f(ax) and f(cx)], 
!    ! this routine isolates the minimum to a fractional precision of 
!    ! about tol using a modification of Brent's method that uses 
!    ! derivatives. The abscissa of the minimum is returned as xmin, 
!    ! and the minimum function value is returned as fmin.
!    !
!    ! The objective function and its derivative must be evaluated 
!    ! in a subroutine upon request:
!    !
!    ! SUBROUTINE fct ( c, need_f, f, need_df, df )
!    !
!    ! with LOGICAL need_f and need_df
!    !
!    IMPLICIT NONE
!    !
!    ! Declaring dummy variables
!    !
!    REAL(8), INTENT(IN) :: ax
!    REAL(8), INTENT(IN) :: bx
!    REAL(8), INTENT(IN) :: cx
!    REAL(8), INTENT(IN) :: tol
!    INTEGER, INTENT(IN) :: itmax
!    REAL(8), INTENT(OUT) :: xmin
!    REAL(8), INTENT(OUT) :: fmin
!    !
!    ! Declaring local variables
!    !
!    INTEGER :: iter
!    REAL(8) :: a,b,d,d1,d2,du,dv,dw,dx,e,fu,fv,fw,fx,olde,fa,da
!    REAL(8) :: tol1,tol2,u,u1,u2,v,w,x,xm
!    LOGICAL :: ok1,ok2
!    !
!    ! Declaring parameters
!    !
!    REAL(8), PARAMETER :: zeps = 1.0d-10
!    !
!    ! Beginning execution
!    !
!    a = MIN(ax,cx)
!    b = MAX(ax,cx)
!    v = bx
!    w = v
!    x = v
!    e = 0.d0
!    CALL fct(x,.TRUE.,fx,.TRUE.,dx)
!    fv = fx
!    fw = fx
!    dv = dx
!    dw = dx
!    !
!    DO iter = 1, itmax
!        !
!        xm = 0.5d0*(a+b)
!        tol1 = tol*ABS(x)+zeps
!        tol2 = 2.d0*tol1
!        !
!        IF (ABS(x-xm) .LE. (tol2-0.5d0*(b-a))) GOTO 3
!        IF (ABS(e) .GT. tol1) THEN
!            d1 = 2.d0*(b-a) 
!            d2 = d1
!            IF (dw .NE. dx) d1 = (w-x)*dx/(dx-dw)
!            IF (dv .NE. dx) d2 = (v-x)*dx/(dx-dv) 
!            u1 = x+d1
!            u2 = x+d2
!            ok1 = ((a-u1)*(u1-b) .GT. 0.d0) .AND. (dx*d1 .LE. 0.d0)
!            ok2 = ((a-u2)*(u2-b) .GT. 0.d0) .AND. (dx*d2 .LE. 0.d0)
!            olde = e
!            e = d
!            IF (.NOT.(ok1 .OR.ok2)) THEN 
!                GOTO 1
!            ELSE IF (ok1 .AND. ok2) THEN
!                IF (ABS(d1) .LT. ABS(d2)) THEN
!                    d=d1
!                ELSE
!                    d=d2
!                END IF
!            ELSE IF (ok1) THEN
!                d=d1
!            ELSE
!                d=d2
!            END IF
!            IF (ABS(d) .GT. ABS(0.5d0*olde)) GOTO 1
!            u=x+d
!            IF (((u-a) .LT. tol2) .OR. ((b-u) .LT. tol2)) d = SIGN(tol1,xm-x)
!            GOTO 2
!        END IF
!        !
!1       IF (dx .GE. 0.) THEN 
!            e = a-x
!        ELSE
!            e = b-x
!        END IF
!        d = 0.5d0*e
!        !
!2       IF (ABS(d) .GE. tol1) THEN
!            u = x+d
!            CALL fct(u,.TRUE.,fu,.FALSE.,da)
!        ELSE
!            u = x+SIGN(tol1,d)
!            CALL fct(u,.TRUE.,fu,.FALSE.,da)
!            IF (fu .GT. fx) GOTO 3 
!        END IF 
!        CALL fct(u,.FALSE.,fa,.FALSE.,du)
!        IF (fu .LE. fx) THEN
!            IF (u .GE. x) THEN
!                a = x
!            ELSE
!                b = x
!            END IF
!            v = w
!            fv = fw
!            dv = dw
!            w = x
!            fw = fx
!            dw = dx
!            x = u
!            fx = fu
!            dx = du
!        ELSE
!            IF (u .LT. x) THEN
!                a = u
!            ELSE
!                b = u
!            END IF
!            IF ((fu .LE. fw) .OR. (w .EQ. x)) THEN
!                v = w
!                fv = fw
!                dv = dw
!                w = u
!                fw = fu
!                dw = du
!            ELSE IF ((fu .LE. fv) .OR. (v .EQ. x) .OR. (v .EQ. w)) THEN
!                v = u
!                fv = fu
!                dv = du
!            END IF
!        END IF
!    END DO
!    !
!    PAUSE 'dbrent exceeded maximum iterations'
!    !
!3   xmin = x
!    fmin = fx
!    RETURN
!    !
!    ! Ending subroutine and returning control
!    !
!    END SUBROUTINE dbrent
!
! %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
!    SUBROUTINE mnbrak ( ax, bx, cx, fa, fb, fc, fct )
!    !
!    ! Based on NR77, 10.1, p. 393-4
!    ! Given a function func, and given distinct initial points ax and bx, 
!    ! this routine searches in the downhill direction (defined by the function 
!    ! as evaluated at the initial points) and returns new points ax, bx, cx 
!    ! that bracket a minimum of the function. Also returned are 
!    ! the function values at the three points, fa, fb, and fc.
!    ! Parameters: GOLD is the default ratio by which successive intervals 
!    ! are magnified; GLIMIT is the maximum magnification allowed 
!    ! for a parabolic-fit step.
!    !
!    ! The objective function and its derivative must be evaluated 
!    ! in a subroutine upon request:
!    !
!    ! SUBROUTINE fct ( c, need_f, f, need_df, df )
!    !
!    ! with LOGICAL need_f and need_df
!    !
!    IMPLICIT NONE
!    !
!    ! Declaring dummy arguments
!    !
!    REAL(8), INTENT(INOUT) :: ax
!    REAL(8), INTENT(INOUT) :: bx
!    REAL(8), INTENT(OUT) :: cx
!    REAL(8), INTENT(OUT) :: fa
!    REAL(8), INTENT(OUT) :: fb
!    REAL(8), INTENT(OUT) :: fc
!    !
!    ! Declaring parameters
!    !
!    REAL(8), PARAMETER :: GOLD = 1.618034d0
!    REAL(8), PARAMETER :: GLIMIT=100.d0
!    REAL(8), PARAMETER :: TINY=1.d-20
!    !
!    ! Declaring local variables
!    !
!    REAL(8) :: dum,fu,q,r,u,ulim,da
!    !
!    ! Beginning execution
!    !
!    CALL fct(ax,.TRUE.,fa,.FALSE.,da)
!    CALL fct(bx,.TRUE.,fb,.FALSE.,da)
!    IF (fb .GT. fa) THEN
!        dum = ax 
!        ax = bx
!        bx = dum
!        dum = fb
!        fb = fa
!        fa = dum
!    END IF
!    !
!    cx = bx+GOLD*(bx-ax) 
!    CALL fct(cx,.TRUE.,fc,.FALSE.,da)
!    !
!1   IF (fb .GE. fc) THEN
!        r = (bx-ax)*(fb-fc) 
!        q = (bx-cx)*(fb-fa)
!        u = bx-((bx-cx)*q-(bx-ax)*r)/(2.*SIGN(MAX(ABS(q-r),TINY),q-r))
!        ulim = bx+GLIMIT*(cx-bx)
!        IF ((bx-u)*(u-cx) .GT. 0.d0) THEN
!            CALL fct(u,.TRUE.,fu,.FALSE.,da)
!            IF (fu .LT. fc) THEN
!                ax = bx
!                fa = fb
!                bx = u
!                fb = fu
!                RETURN
!            ELSE IF (fu .GT. fb) THEN 
!                cx = u
!                fc = fu
!                RETURN
!            END IF
!            !
!            u = cx+GOLD*(cx-bx) 
!            CALL fct(u,.TRUE.,fu,.FALSE.,da)
!        ELSE IF ((cx-u)*(u-ulim) .GT. 0.d0) THEN 
!            CALL fct(u,.TRUE.,fu,.FALSE.,da)
!            IF (fu .LT. fc) THEN
!                bx = cx
!                cx = u
!                u = cx+GOLD*(cx-bx)
!                fb = fc
!                fc = fu
!                CALL fct(u,.TRUE.,fu,.FALSE.,da)
!            END IF
!        ELSE IF ((u-ulim)*(ulim-cx) .GE. 0.d0) THEN
!            u = ulim
!            CALL fct(u,.TRUE.,fu,.FALSE.,da)
!        ELSE
!            u = cx+GOLD*(cx-bx)
!            CALL fct(u,.TRUE.,fu,.FALSE.,da)
!        END IF
!        !
!        ax = bx
!        bx = cx
!        cx = u
!        fa = fb
!        fb = fc
!        fc = fu
!        GOTO 1
!    END IF
!    !
!    RETURN
!    !
!    ! Ending execution and returning control
!    !
!    END SUBROUTINE mnbrak
!
! %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
!
!
! %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
  FUNCTION CDF_N01(x, upper)
    IMPLICIT NONE
!
! Ending execution
!
!
! cdf_N01 computes the cumulative density of the standard normal distribution.
! It can be differentiated automatically by TAPENADE
!
! cdf_N01 is based on the ALNORM function
! Original FORTRAN77 version by David Hill.
! FORTRAN90 version by John Burkardt.
!
!  Parameters:
!
!    Input, real ( kind = 8 ) X, is one endpoint of the semi-infinite interval
!    over which the integration takes place.
!
!    Input, logical UPPER, determines whether the upper or lower
!    interval is to be integrated:
!    .TRUE.  => integrate from X to + Infinity;
!    .FALSE. => integrate from - Infinity to X.
!
!    Output, real ( kind = 8 ) ALNORM, the integral of the standard normal
!    distribution over the desired interval.
!
! Declaring dummy variables
!
    REAL*8, INTENT(IN) :: x
    LOGICAL, INTENT(IN) :: upper
!
! Declaring local variables
!
    LOGICAL :: up
    REAL*8 :: y, z
!
! Declaring parameters
!
    REAL*8, PARAMETER :: a1=5.75885480458d+00
    REAL*8, PARAMETER :: a2=2.62433121679d+00
    REAL*8, PARAMETER :: a3=5.92885724438d+00
    REAL*8, PARAMETER :: b1=-29.8213557807d+00
    REAL*8, PARAMETER :: b2=48.6959930692d+00
    REAL*8, PARAMETER :: c1=-0.000000038052d+00
    REAL*8, PARAMETER :: c2=0.000398064794d+00
    REAL*8, PARAMETER :: c3=-0.151679116635d+00
    REAL*8, PARAMETER :: c4=4.8385912808d+00
    REAL*8, PARAMETER :: c5=0.742380924027d+00
    REAL*8, PARAMETER :: c6=3.99019417011d+00
    REAL*8, PARAMETER :: con=1.28d+00
    REAL*8, PARAMETER :: d1=1.00000615302d+00
    REAL*8, PARAMETER :: d2=1.98615381364d+00
    REAL*8, PARAMETER :: d3=5.29330324926d+00
    REAL*8, PARAMETER :: d4=-15.1508972451d+00
    REAL*8, PARAMETER :: d5=30.789933034d+00
    REAL*8, PARAMETER :: ltone=7.0d+00
    REAL*8, PARAMETER :: p=0.398942280444d+00
    REAL*8, PARAMETER :: q=0.39990348504d+00
    REAL*8, PARAMETER :: r=0.398942280385d+00
    REAL*8, PARAMETER :: utzero=18.66d+00
!
! Declaring function's type
!
    REAL*8 :: cdf_n01
    INTRINSIC EXP
!
! Beginning execution
!
    up = upper
    z = x
!
    IF (z .LT. 0.0d+00) THEN
      up = .NOT.up
      z = -z
    END IF
!
    IF (ltone .LT. z .AND. ((.NOT.up) .OR. utzero .LT. z)) THEN
!
      IF (up) THEN
        cdf_n01 = 0.0d+00
      ELSE
        cdf_n01 = 1.0d+00
      END IF
      RETURN
!
    ELSE
!
      y = 0.5d+00*z*z
!
      IF (z .LE. con) THEN
        cdf_n01 = 0.5d+00 - z*(p-q*y/(y+a1+b1/(y+a2+b2/(y+a3))))
      ELSE
        cdf_n01 = r*EXP(-y)/(z+c1+d1/(z+c2+d2/(z+c3+d3/(z+c4+d4/(z+c5+d5&
&         /(z+c6))))))
      END IF
      IF (.NOT.up) cdf_n01 = 1.0d+00 - cdf_n01
      RETURN
    END IF
  END FUNCTION CDF_N01

!  Differentiation of pdf_n01_dv in forward (tangent) mode (with options multiDirectional i4 dr8 r4):
!   variations   of useful results: pdf_n01 pdf_n01d
!   with respect to varying inputs: xd x
!  Differentiation of pdf_n01 in forward (tangent) mode (with options multiDirectional i4 dr8 r4):
!   variations   of useful results: pdf_n01
!   with respect to varying inputs: x
!
! %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
  SUBROUTINE PDF_N01_DV_DV(x, xd0, xd, xdd, pdf_n01, pdf_n01d0, pdf_n01d&
&   , pdf_n01dd, nbdirs, nbdirs0)
    USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
    IMPLICIT NONE
!
! Ending execution and returning control
!
!
! Declaring dummy variables
!
    REAL*8, INTENT(IN) :: x
    REAL*8, DIMENSION(nbdirsmax0), INTENT(IN) :: xd0
    REAL*8, DIMENSION(nbdirsmax), INTENT(IN) :: xd
    REAL*8, DIMENSION(nbdirsmax0, nbdirsmax), INTENT(IN) :: xdd
!
! Declaring function's type
!
    REAL*8 :: pdf_n01
    REAL*8, DIMENSION(nbdirsmax0) :: pdf_n01d0
    REAL*8, DIMENSION(nbdirsmax) :: pdf_n01d
    REAL*8, DIMENSION(nbdirsmax0, nbdirsmax) :: pdf_n01dd
!
! Declaring constants
!
    REAL*8, PARAMETER :: pi=3.14159265358979323846264338328d0
    INTRINSIC SQRT
    INTRINSIC EXP
    REAL*8 :: arg1
    REAL*8 :: result1
    REAL*8 :: arg2
    REAL*8, DIMENSION(nbdirsmax0) :: arg2d0
    REAL*8, DIMENSION(nbdirsmax) :: arg2d
    REAL*8, DIMENSION(nbdirsmax0, nbdirsmax) :: arg2dd
    INTEGER :: nd
    INTEGER :: nbdirs
    INTEGER :: nd0
    INTEGER :: nbdirs0
!
! Beginning execution
!
    arg1 = 2.d0*pi
    result1 = SQRT(arg1)
    DO nd0=1,nbdirs0
      arg2d0(nd0) = -(2*x*xd0(nd0)/2.d0)
    END DO
    arg2 = -(x**2/2.d0)
    pdf_n01dd(:, :) = 0.0_8
    arg2dd(:, :) = 0.0_8
    DO nd=1,nbdirs
      arg2d(nd) = -(2*x*xd(nd)/2.d0)
      DO nd0=1,nbdirs0
        arg2dd(nd0, nd) = -(2*(xd0(nd0)*xd(nd)+x*xdd(nd0, nd))/2.d0)
        pdf_n01dd(nd0, nd) = (arg2dd(nd0, nd)*EXP(arg2)+arg2d(nd)*arg2d0&
&         (nd0)*EXP(arg2))/result1
      END DO
      pdf_n01d(nd) = arg2d(nd)*EXP(arg2)/result1
    END DO
    DO nd0=1,nbdirs0
      pdf_n01d0(nd0) = arg2d0(nd0)*EXP(arg2)/result1
    END DO
    pdf_n01 = 1.d0/result1*EXP(arg2)
  END SUBROUTINE PDF_N01_DV_DV

!  Differentiation of pdf_n01 in forward (tangent) mode (with options multiDirectional i4 dr8 r4):
!   variations   of useful results: pdf_n01
!   with respect to varying inputs: x
!
! %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
  SUBROUTINE PDF_N01_DV(x, xd, pdf_n01, pdf_n01d, nbdirs)
    USE DIFFSIZES
    IMPLICIT NONE
!
! Ending execution and returning control
!
!
! Declaring dummy variables
!
    REAL*8, INTENT(IN) :: x
    REAL*8, DIMENSION(nbdirsmax), INTENT(IN) :: xd
!
! Declaring function's type
!
    REAL*8 :: pdf_n01
    REAL*8, DIMENSION(nbdirsmax) :: pdf_n01d
!
! Declaring constants
!
    REAL*8, PARAMETER :: pi=3.14159265358979323846264338328d0
    INTRINSIC SQRT
    INTRINSIC EXP
    REAL*8 :: arg1
    REAL*8 :: result1
    REAL*8 :: arg2
    REAL*8, DIMENSION(nbdirsmax) :: arg2d
    INTEGER :: nd
    INTEGER :: nbdirs
!
! Beginning execution
!
    arg1 = 2.d0*pi
    result1 = SQRT(arg1)
    arg2 = -(x**2/2.d0)
    DO nd=1,nbdirs
      arg2d(nd) = -(2*x*xd(nd)/2.d0)
      pdf_n01d(nd) = arg2d(nd)*EXP(arg2)/result1
    END DO
    pdf_n01 = 1.d0/result1*EXP(arg2)
  END SUBROUTINE PDF_N01_DV

!
! %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
  FUNCTION PDF_N01(x)
    IMPLICIT NONE
!
! Ending execution and returning control
!
!
! Declaring dummy variables
!
    REAL*8, INTENT(IN) :: x
!
! Declaring function's type
!
    REAL*8 :: pdf_n01
!
! Declaring constants
!
    REAL*8, PARAMETER :: pi=3.14159265358979323846264338328d0
    INTRINSIC SQRT
    INTRINSIC EXP
    REAL*8 :: arg1
    REAL*8 :: result1
    REAL*8 :: arg2
!
! Beginning execution
!
    arg1 = 2.d0*pi
    result1 = SQRT(arg1)
    arg2 = -(x**2/2.d0)
    pdf_n01 = 1.d0/result1*EXP(arg2)
  END FUNCTION PDF_N01

!
! %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
  FUNCTION CDF_BIV_N01(u1, u2, r)
    IMPLICIT NONE
!
!
! cdf_biv_N01 computes the (upper tail) probability for two normal variates X and Y
! whose correlation is R, that X >= u1 and Y >= u2.
! It can be differentiated automatically by TAPENADE    
!
! Original FORTRAN77 version by Thomas Donnelly.
! FORTRAN90 version by John Burkardt.
!
!  Parameters:
!    Input, real ( kind = 8 ) u1, u2, the lower limits of integration.
!    Input, real ( kind = 8 ) R, the correlation between X and Y.
!    Output, real ( kind = 8 ) cdf_biv_N01, the bivariate normal CDF.
!
!  Local Parameters:
!    Local, integer ( kind = 4 ) IDIG, the number of significant digits
!    to the right of the decimal point desired in the answer.
!
! Declaring dummy variables
!
    REAL*8, INTENT(IN) :: u1
    REAL*8, INTENT(IN) :: u2
    REAL*8, INTENT(IN) :: r
!
! Declaring local variables
!
    INTEGER*4 :: i, is
    REAL*8 :: a2, ap, b, cn, con, conex, ex, g2, gh, gk, gw, h2, h4
    REAL*8 :: rr, s1, s2, sgn, sn, sp, sqr, t, w2, wh, wk
! 
! Declaring function's type
!
    REAL*8 :: cdf_biv_n01
!
! Declaring parameters
!
    INTEGER*4, PARAMETER :: idig=15
    REAL*8, PARAMETER :: twopi=6.283185307179587d+00
    INTRINSIC MAX
    INTRINSIC MIN
    INTRINSIC SQRT
    INTRINSIC ASIN
    INTRINSIC ABS
    INTRINSIC EXP
    INTRINSIC ATAN
    REAL*8 :: abs0
    REAL*8 :: abs1
    REAL*8 :: abs2
    REAL*8 :: result1
!
! Beginning execution
!
    b = 0.0d+00
    result1 = CDF_N01(-u1, .false.)
    gh = result1/2.0d+00
    result1 = CDF_N01(-u2, .false.)
    gk = result1/2.0d+00
    IF (r .EQ. 0.0d+00) THEN
      b = 4.0d+000*gh*gk
      IF (b .LT. 0.0d+00) THEN
        b = 0.0d+00
      ELSE
        b = b
      END IF
      IF (b .GT. 1.0d+00) THEN
        b = 1.0d+00
      ELSE
        b = b
      END IF
      cdf_biv_n01 = b
      RETURN
    ELSE
!
      rr = (1.0d+00+r)*(1.0d+00-r)
!
      IF (rr .LT. 0.0d+00) THEN
        WRITE(*, '(a)') ' '
        WRITE(*, '(a)') 'cdf_biv_N01 - Fatal error!'
        WRITE(*, '(a)') '  1 < |R|.'
        STOP
      ELSE IF (rr .EQ. 0.0d+00) THEN
!
        IF (r .LT. 0.0d+00) THEN
          IF (u1 + u2 .LT. 0.0d+00) b = 2.0d+00*(gh+gk) - 1.0d+00
        ELSE IF (u1 - u2 .LT. 0.0d+00) THEN
          b = 2.0d+00*gk
        ELSE
          b = 2.0d+00*gh
        END IF
        IF (b .LT. 0.0d+00) THEN
          b = 0.0d+00
        ELSE
          b = b
        END IF
        IF (b .GT. 1.0d+00) THEN
          b = 1.0d+00
        ELSE
          b = b
        END IF
        cdf_biv_n01 = b
        RETURN
      ELSE
!
        sqr = SQRT(rr)
!
        IF (idig .EQ. 15) THEN
          con = twopi*1.0d-15/2.0d+00
        ELSE
          con = twopi/2.0d+00
          DO i=1,idig
            con = con/10.0d+00
          END DO
        END IF
!
!  (0,0)
!
        IF (u1 .EQ. 0.0d+00 .AND. u2 .EQ. 0.0d+00) THEN
          result1 = ASIN(r)
          b = 0.25d+00 + result1/twopi
          IF (b .LT. 0.0d+00) THEN
            b = 0.0d+00
          ELSE
            b = b
          END IF
          IF (b .GT. 1.0d+00) THEN
            b = 1.0d+00
          ELSE
            b = b
          END IF
          cdf_biv_n01 = b
          RETURN
        ELSE
!
!  (0,nonzero)
!
          IF (u1 .EQ. 0.0d+00 .AND. u2 .NE. 0.0d+00) THEN
            b = gk
            wh = -u2
            wk = (u1/u2-r)/sqr
            gw = 2.0d+00*gk
            is = 1
!
!  (nonzero,0)
!
          ELSE IF (u1 .NE. 0.0d+00 .AND. u2 .EQ. 0.0d+00) THEN
            b = gh
            wh = -u1
            wk = (u2/u1-r)/sqr
            gw = 2.0d+00*gh
            is = -1
!
!  (nonzero,nonzero)
!
          ELSE IF (u1 .NE. 0.0 .AND. u2 .NE. 0.0) THEN
            b = gh + gk
            IF (u1*u2 .LT. 0.0d+00) b = b - 0.5d+00
            wh = -u1
            wk = (u2/u1-r)/sqr
            gw = 2.0d+00*gh
            is = -1
          END IF
!
          DO 110 
            sgn = -1.0d+00
            t = 0.0d+00
            IF (wk .NE. 0.0d+00) THEN
              IF (wk .GE. 0.) THEN
                abs0 = wk
              ELSE
                abs0 = -wk
              END IF
              IF (abs0 .EQ. 1.0d+00) THEN
                t = wk*gw*(1.0d+00-gw)/2.0d+00
                b = b + sgn*t
              ELSE
                IF (wk .GE. 0.) THEN
                  abs1 = wk
                ELSE
                  abs1 = -wk
                END IF
                IF (1.0d+00 .LT. abs1) THEN
                  sgn = -sgn
                  wh = wh*wk
                  g2 = CDF_N01(wh, .false.)
                  wk = 1.0d+00/wk
                  IF (wk .LT. 0.0d+00) b = b + 0.5d+00
                  b = b - (gw+g2)/2.0d+00 + gw*g2
                END IF
                h2 = wh*wh
                a2 = wk*wk
                h4 = h2/2.0d+00
                ex = EXP(-h4)
                w2 = h4*ex
                ap = 1.0d+00
                s2 = ap - ex
                sp = ap
                s1 = 0.0d+00
                sn = s1
                IF (con/wk .GE. 0.) THEN
                  conex = con/wk
                ELSE
                  conex = -(con/wk)
                END IF
!
                DO 
                  cn = ap*s2/(sn+sp)
                  s1 = s1 + cn
                  IF (cn .GE. 0.) THEN
                    abs2 = cn
                  ELSE
                    abs2 = -cn
                  END IF
                  IF (abs2 .LE. conex) THEN
                    t = (ATAN(wk)-wk*s1)/twopi
                    b = b + sgn*t
                    GOTO 100
                  ELSE
!
                    sn = sp
                    sp = sp + 1.0d+00
                    s2 = s2 - w2
                    w2 = w2*h4/sp
                    ap = -(ap*a2)
                  END IF
                END DO
              END IF
            END IF
!
 100        IF (0 .GT. is) THEN
!
              IF (u2 .NE. 0.0d+00) THEN
                wh = -u2
                wk = (u1/u2-r)/sqr
                gw = 2.0d+00*gk
                is = 1
                GOTO 110
              END IF
            END IF
            IF (b .LT. 0.0d+00) THEN
              b = 0.0d+00
            ELSE
              b = b
            END IF
            IF (b .GT. 1.0d+00) THEN
              b = 1.0d+00
            ELSE
              b = b
            END IF
            cdf_biv_n01 = b
            RETURN
 110      CONTINUE
        END IF
      END IF
    END IF
  END FUNCTION CDF_BIV_N01

!
! %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
  FUNCTION PDF_BIV_N01(u1, u2, r)
    IMPLICIT NONE
!
! Ending execution and returning control
!
!
! Declaring dummy variables
!
    REAL*8, INTENT(IN) :: u1
    REAL*8, INTENT(IN) :: u2
    REAL*8, INTENT(IN) :: r
!
! Declaring local variables
!
    REAL*8 :: q
!
! Declaring function's type
!
    REAL*8 :: pdf_biv_n01
!
! Declaring constants
!
    REAL*8, PARAMETER :: pi=3.14159265358979323846264338328d0
    INTRINSIC EXP
    INTRINSIC SQRT
    REAL*8 :: arg1
    REAL*8 :: result1
!
! Beginning execution
!
    q = 1.d0 - r**2
    arg1 = (-(u2*(u2/q-u1*r/q))-u1*(u1/q-u2*r/q))/2.d0
    result1 = SQRT(q)
    pdf_biv_n01 = EXP(arg1)/(2.*pi*result1)
  END FUNCTION PDF_BIV_N01

END MODULE SP_DIFFV_DIFFV

