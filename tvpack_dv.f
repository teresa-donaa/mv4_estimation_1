C        Generated by TAPENADE     (INRIA, Ecuador team)
C  Tapenade 3.14 (r7259) - 18 Jan 2019 09:34
C
C  Differentiation of tvtl in forward (tangent) mode (with options multiDirectional i4 dr8 r4):
C   variations   of useful results: tvtl
C   with respect to varying inputs: h r
C
C This file is adapted from the TVPACK.F file by Alan Genz available from
C http://www.math.wsu.edu/faculty/genz/software/fort77/tvpack.fhttp://www.math.wsu.edu/faculty/genz/software/fort77/tvpack.f
C It contains functions TVTL (trivariate normal 
C and t), BVTL (bivariate t), BVND (bivariate normal), STUDNT (univariate
C t), PHID (univariate normal), plus some support functions.
C
      SUBROUTINE TVTL_DV(nu, h, hd, r, rd, epsi, tvtl, tvtld, nbdirs)
      USE DIFFSIZES
      IMPLICIT NONE
C  Hint: nbdirsmax should be the maximum number of differentiation directions
C    
C     A function for computing trivariate normal and t-probabilities.
C     This function uses algorithms developed from the ideas 
C     described in the papers:
C       R.L. Plackett, Biometrika 41(1954), pp. 351-360.
C       Z. Drezner, Math. Comp. 62(1994), pp. 289-294.
C     with adaptive integration from (0,0,1) to (0,0,r23) to R. 
C
C      Calculate the probability that X(I) < H(I), for I = 1,2,3     
C    NU   INTEGER degrees of freedom; use NU = 0 for normal cases.
C    H    REAL array of uppoer limits for probability distribution 
C    R    REAL array of three correlation coefficients, R should 
C         contain the lower left portion of the correlation matrix r. 
C         R should contains the values r21, r31, r23 in that order.
C   EPSI  REAL required absolute accuracy; maximum accuracy for most
C          computations is approximately 1D-14
C 
      REAL(8), EXTERNAL :: TVTMFN
      INTEGER nu, nuc
      DOUBLE PRECISION h(3), h1, h2, h3, r(3), r12, r13, r23, epsi
      DOUBLE PRECISION hd(nbdirsmax, 3), h1d(nbdirsmax), h2d(nbdirsmax)
     +                 , h3d(nbdirsmax), rd(nbdirsmax, 3), r12d(
     +                 nbdirsmax), r13d(nbdirsmax), r23d(nbdirsmax)
      DOUBLE PRECISION one, zro, eps, zros(3), hs(3), tvt
      DOUBLE PRECISION tvtd(nbdirsmax)
      DOUBLE PRECISION rua, rub, ar, ruc, pt, BVTL, PHID, ADONET
      PARAMETER (zro=0, one=1)
      COMMON /tvtmbk/ h1, h2, h3, r23, rua, rub, ar, ruc, nuc
      INTRINSIC MAX
      INTRINSIC ASIN
      INTRINSIC ABS
      INTRINSIC MIN
      INTRINSIC SIGN
      DOUBLE PRECISION abs0
      DOUBLE PRECISION abs1
      DOUBLE PRECISION abs2
      DOUBLE PRECISION abs3
      DOUBLE PRECISION abs4
      DOUBLE PRECISION abs5
      DOUBLE PRECISION min1
      DOUBLE PRECISION min1d(nbdirsmax)
      DOUBLE PRECISION min2
      DOUBLE PRECISION min2d(nbdirsmax)
      DOUBLE PRECISION abs6
      DOUBLE PRECISION abs7
      DOUBLE PRECISION abs8
      DOUBLE PRECISION abs9
      DOUBLE PRECISION abs10
      DOUBLE PRECISION abs11
      DOUBLE PRECISION abs12
      DOUBLE PRECISION result1
      DOUBLE PRECISION result1d(nbdirsmax)
      DOUBLE PRECISION result2
      DOUBLE PRECISION result2d(nbdirsmax)
      DOUBLE PRECISION result3
      DOUBLE PRECISION result3d(nbdirsmax)
      INTEGER nd
      DOUBLE PRECISION dummyzerodiffd(nbdirsmax)
      DOUBLE PRECISION dummyzerodiffd0(nbdirsmax)
      DOUBLE PRECISION dummyzerodiffd1(nbdirsmax)
      DOUBLE PRECISION y1d(nbdirsmax)
      DOUBLE PRECISION tvtl
      DOUBLE PRECISION tvtld(nbdirsmax)
      INTEGER nbdirs
      DOUBLE PRECISION y1
      IF (1d-14 .LT. epsi) THEN
        eps = epsi
      ELSE
        eps = 1d-14
      END IF
      pt = ASIN(one)
      nuc = nu
      DO nd=1,nbdirs
        h1d(nd) = hd(nd, 1)
        h2d(nd) = hd(nd, 2)
        h3d(nd) = hd(nd, 3)
        r12d(nd) = rd(nd, 1)
        r13d(nd) = rd(nd, 2)
        r23d(nd) = rd(nd, 3)
      ENDDO
      h1 = h(1)
      h2 = h(2)
      h3 = h(3)
      r12 = r(1)
      r13 = r(2)
      r23 = r(3)
      IF (r12 .GE. 0.) THEN
        abs0 = r12
      ELSE
        abs0 = -r12
      END IF
      IF (r13 .GE. 0.) THEN
        abs6 = r13
      ELSE
        abs6 = -r13
      END IF
C
C     Sort R's and check for special cases
C
      IF (abs0 .GT. abs6) THEN
        DO nd=1,nbdirs
          h2d(nd) = h3d(nd)
          h3d(nd) = hd(nd, 2)
          r12d(nd) = r13d(nd)
          r13d(nd) = rd(nd, 1)
        ENDDO
        h2 = h3
        h3 = h(2)
        r12 = r13
        r13 = r(1)
      END IF
      IF (r13 .GE. 0.) THEN
        abs1 = r13
      ELSE
        abs1 = -r13
      END IF
      IF (r23 .GE. 0.) THEN
        abs7 = r23
      ELSE
        abs7 = -r23
      END IF
      IF (abs1 .GT. abs7) THEN
        DO nd=1,nbdirs
          h1d(nd) = h2d(nd)
          h2d(nd) = hd(nd, 1)
          r23d(nd) = r13d(nd)
          r13d(nd) = rd(nd, 3)
        ENDDO
        h1 = h2
        h2 = h(1)
        r23 = r13
        r13 = r(3)
      END IF
      tvt = 0
      IF (h1 .GE. 0.) THEN
        abs2 = h1
      ELSE
        abs2 = -h1
      END IF
      IF (h2 .GE. 0.) THEN
        abs8 = h2
      ELSE
        abs8 = -h2
      END IF
      IF (h3 .GE. 0.) THEN
        abs12 = h3
      ELSE
        abs12 = -h3
      END IF
      IF (abs2 + abs8 + abs12 .LT. eps) THEN
        DO nd=1,nbdirs
          IF (r12 .EQ. 1.0 .OR. r12 .EQ. (-1.0)) THEN
            result1d(nd) = 0.D0
          ELSE
            result1d(nd) = r12d(nd)/SQRT(1.0-r12**2)
          END IF
          IF (r13 .EQ. 1.0 .OR. r13 .EQ. (-1.0)) THEN
            result2d(nd) = 0.D0
          ELSE
            result2d(nd) = r13d(nd)/SQRT(1.0-r13**2)
          END IF
          IF (r23 .EQ. 1.0 .OR. r23 .EQ. (-1.0)) THEN
            result3d(nd) = 0.D0
          ELSE
            result3d(nd) = r23d(nd)/SQRT(1.0-r23**2)
          END IF
          tvtd(nd) = (result1d(nd)+result2d(nd)+result3d(nd))/pt/8
        ENDDO
        result1 = ASIN(r12)
        result2 = ASIN(r13)
        result3 = ASIN(r23)
        tvt = (1+(result1+result2+result3)/pt)/8
      ELSE
        IF (r12 .GE. 0.) THEN
          abs3 = r12
        ELSE
          abs3 = -r12
        END IF
        IF (r13 .GE. 0.) THEN
          abs9 = r13
        ELSE
          abs9 = -r13
        END IF
        IF (nu .LT. 1 .AND. abs3 + abs9 .LT. eps) THEN
          CALL PHID_DV(h1, h1d, result1, result1d, nbdirs)
          CALL BVTL_DV(nu, h2, h2d, h3, h3d, r23, r23d, result2, 
     +                 result2d, nbdirs)
          DO nd=1,nbdirs
            tvtd(nd) = result1d(nd)*result2 + result1*result2d(nd)
          ENDDO
          tvt = result1*result2
        ELSE
          IF (r13 .GE. 0.) THEN
            abs4 = r13
          ELSE
            abs4 = -r13
          END IF
          IF (r23 .GE. 0.) THEN
            abs10 = r23
          ELSE
            abs10 = -r23
          END IF
          IF (nu .LT. 1 .AND. abs4 + abs10 .LT. eps) THEN
            CALL PHID_DV(h3, h3d, result1, result1d, nbdirs)
            CALL BVTL_DV(nu, h1, h1d, h2, h2d, r12, r12d, result2, 
     +                   result2d, nbdirs)
            DO nd=1,nbdirs
              tvtd(nd) = result1d(nd)*result2 + result1*result2d(nd)
            ENDDO
            tvt = result1*result2
          ELSE
            IF (r12 .GE. 0.) THEN
              abs5 = r12
            ELSE
              abs5 = -r12
            END IF
            IF (r23 .GE. 0.) THEN
              abs11 = r23
            ELSE
              abs11 = -r23
            END IF
            IF (nu .LT. 1 .AND. abs5 + abs11 .LT. eps) THEN
              CALL PHID_DV(h2, h2d, result1, result1d, nbdirs)
              CALL BVTL_DV(nu, h1, h1d, h3, h3d, r13, r13d, result2, 
     +                     result2d, nbdirs)
              DO nd=1,nbdirs
                tvtd(nd) = result1d(nd)*result2 + result1*result2d(nd)
              ENDDO
              tvt = result1*result2
            ELSE IF (1 - r23 .LT. eps) THEN
              IF (h2 .GT. h3) THEN
                DO nd=1,nbdirs
                  min1d(nd) = h3d(nd)
                ENDDO
                min1 = h3
              ELSE
                DO nd=1,nbdirs
                  min1d(nd) = h2d(nd)
                ENDDO
                min1 = h2
              END IF
              CALL BVTL_DV(nu, h1, h1d, min1, min1d, r12, r12d, tvt, 
     +                     tvtd, nbdirs)
            ELSE IF (r23 + 1 .LT. eps) THEN
              IF (h2 .GT. -h3) THEN
                CALL BVTL_DV(nu, h1, h1d, h2, h2d, r12, r12d, result1, 
     +                       result1d, nbdirs)
                CALL BVTL_DV(nu, h1, h1d, -h3, -h3d, r12, r12d, result2
     +                       , result2d, nbdirs)
                DO nd=1,nbdirs
                  tvtd(nd) = result1d(nd) - result2d(nd)
                ENDDO
                tvt = result1 - result2
              ELSE
                DO nd=1,nbdirsmax
                  tvtd(nd) = 0.D0
                ENDDO
              END IF
            ELSE
C
C        Compute singular TVT value
C
              IF (nu .LT. 1) THEN
                CALL BVTL_DV(nu, h2, h2d, h3, h3d, r23, r23d, result1, 
     +                       result1d, nbdirs)
                CALL PHID_DV(h1, h1d, result2, result2d, nbdirs)
                DO nd=1,nbdirs
                  tvtd(nd) = result1d(nd)*result2 + result1*result2d(nd)
                ENDDO
                tvt = result1*result2
              ELSE IF (r23 .GE. 0) THEN
                IF (h2 .GT. h3) THEN
                  DO nd=1,nbdirs
                    min2d(nd) = h3d(nd)
                  ENDDO
                  min2 = h3
                ELSE
                  DO nd=1,nbdirs
                    min2d(nd) = h2d(nd)
                  ENDDO
                  min2 = h2
                END IF
                DO nd=1,nbdirsmax
                  dummyzerodiffd(nd) = 0.D0
                ENDDO
                CALL BVTL_DV(nu, h1, h1d, min2, min2d, zro, 
     +                       dummyzerodiffd, tvt, tvtd, nbdirs)
              ELSE IF (h2 .GT. -h3) THEN
                DO nd=1,nbdirsmax
                  dummyzerodiffd0(nd) = 0.D0
                ENDDO
                CALL BVTL_DV(nu, h1, h1d, h2, h2d, zro, dummyzerodiffd0
     +                       , result1, result1d, nbdirs)
                DO nd=1,nbdirsmax
                  dummyzerodiffd1(nd) = 0.D0
                ENDDO
                CALL BVTL_DV(nu, h1, h1d, -h3, -h3d, zro, 
     +                       dummyzerodiffd1, result2, result2d, nbdirs)
                DO nd=1,nbdirs
                  tvtd(nd) = result1d(nd) - result2d(nd)
                ENDDO
                tvt = result1 - result2
              ELSE
                DO nd=1,nbdirsmax
                  tvtd(nd) = 0.D0
                ENDDO
              END IF
C
C        Use numerical integration to compute probability
C
C
              rua = ASIN(r12)
              rub = ASIN(r13)
              ar = ASIN(r23)
              ruc = SIGN(pt, ar) - ar
              result1 = ADONET(tvtmfn, zro, one, eps)
              tvt = tvt + result1/(4*pt)
            END IF
          END IF
        END IF
      END IF
      IF (tvt .GT. one) THEN
        y1 = one
        DO nd=1,nbdirsmax
          y1d(nd) = 0.D0
        ENDDO
      ELSE
        DO nd=1,nbdirs
          y1d(nd) = tvtd(nd)
        ENDDO
        y1 = tvt
      END IF
      IF (zro .LT. y1) THEN
        DO nd=1,nbdirs
          tvtld(nd) = y1d(nd)
        ENDDO
        tvtl = y1
      ELSE
        tvtl = zro
        DO nd=1,nbdirsmax
          tvtld(nd) = 0.D0
        ENDDO
      END IF
      END

C  Differentiation of bvtl in forward (tangent) mode (with options multiDirectional i4 dr8 r4):
C   variations   of useful results: bvtl
C   with respect to varying inputs: dh dk r
C
      SUBROUTINE BVTL_DV(nu, dh, dhd, dk, dkd, r, rd, bvtl, bvtld, 
     +                   nbdirs)
      USE DIFFSIZES
      IMPLICIT NONE
C     END BVTL
C  Hint: nbdirsmax should be the maximum number of differentiation directions
C
C     A function for computing bivariate t probabilities.
C
C       Alan Genz
C       Department of Mathematics
C       Washington State University
C       Pullman, WA 99164-3113
C       Email : alangenz@wsu.edu
C
C    This function is based on the method described by 
C        Dunnett, C.W. and M. Sobel, (1954),
C        A bivariate generalization of Student's t-distribution
C        with tables for certain special cases,
C        Biometrika 41, pp. 153-169.
C
C BVTL - calculate the probability that X < DH and Y < DK. 
C
C parameters
C
C   NU number of degrees of freedom
C   DH 1st lower integration limit
C   DK 2nd lower integration limit
C   R   correlation coefficient
C
      INTEGER nu, j, hs, ks
      DOUBLE PRECISION dh, dk, r
      DOUBLE PRECISION dhd(nbdirsmax), dkd(nbdirsmax), rd(nbdirsmax)
      DOUBLE PRECISION tpi, pi, ors, hrk, krh, bvt, snu, BVND, STUDNT
      DOUBLE PRECISION orsd(nbdirsmax), hrkd(nbdirsmax), krhd(nbdirsmax)
     +                 , bvtd(nbdirsmax)
      DOUBLE PRECISION gmph, gmpk, xnkh, xnhk, qhrk, hkn, hpk, hkrn
      DOUBLE PRECISION gmphd(nbdirsmax), gmpkd(nbdirsmax), xnkhd(
     +                 nbdirsmax), xnhkd(nbdirsmax), qhrkd(nbdirsmax), 
     +                 hknd(nbdirsmax), hpkd(nbdirsmax), hkrnd(nbdirsmax
     +                 )
      DOUBLE PRECISION btnckh, btnchk, btpdkh, btpdhk, one, eps
      DOUBLE PRECISION btnckhd(nbdirsmax), btnchkd(nbdirsmax), btpdkhd(
     +                 nbdirsmax), btpdhkd(nbdirsmax)
      PARAMETER (one=1, eps=1d-15)
      INTRINSIC MIN
      INTRINSIC ACOS
      INTRINSIC SQRT
      INTRINSIC ABS
      INTRINSIC SIGN
      INTRINSIC MOD
      INTRINSIC ATAN2
      DOUBLE PRECISION min1
      DOUBLE PRECISION min1d(nbdirsmax)
      DOUBLE PRECISION abs0
      DOUBLE PRECISION result1
      DOUBLE PRECISION result1d(nbdirsmax)
      DOUBLE PRECISION result2
      DOUBLE PRECISION result2d(nbdirsmax)
      DOUBLE PRECISION arg1
      DOUBLE PRECISION arg1d(nbdirsmax)
      DOUBLE PRECISION arg2
      DOUBLE PRECISION arg2d(nbdirsmax)
      INTEGER nd
      DOUBLE PRECISION bvtld(nbdirsmax)
      DOUBLE PRECISION bvtl
      INTEGER nbdirs
      IF (nu .LT. 1) THEN
        CALL BVND_DV(-dh, -dhd, -dk, -dkd, r, rd, bvtl, bvtld, nbdirs)
      ELSE IF (1 - r .LE. eps) THEN
        IF (dh .GT. dk) THEN
          DO nd=1,nbdirs
            min1d(nd) = dkd(nd)
          ENDDO
          min1 = dk
        ELSE
          DO nd=1,nbdirs
            min1d(nd) = dhd(nd)
          ENDDO
          min1 = dh
        END IF
        CALL STUDNT_DV(nu, min1, min1d, bvtl, bvtld, nbdirs)
      ELSE IF (r + 1 .LE. eps) THEN
        IF (dh .GT. -dk) THEN
          CALL STUDNT_DV(nu, dh, dhd, result1, result1d, nbdirs)
          CALL STUDNT_DV(nu, -dk, -dkd, result2, result2d, nbdirs)
          DO nd=1,nbdirs
            bvtld(nd) = result1d(nd) - result2d(nd)
          ENDDO
          bvtl = result1 - result2
        ELSE
          bvtl = 0
          DO nd=1,nbdirsmax
            bvtld(nd) = 0.D0
          ENDDO
        END IF
      ELSE
        pi = ACOS(-one)
        tpi = 2*pi
        snu = nu
        snu = SQRT(snu)
        DO nd=1,nbdirs
          orsd(nd) = -(rd(nd)*r) - r*rd(nd)
          hrkd(nd) = dhd(nd) - rd(nd)*dk - r*dkd(nd)
          krhd(nd) = dkd(nd) - rd(nd)*dh - r*dhd(nd)
        ENDDO
        ors = 1 - r*r
        hrk = dh - r*dk
        krh = dk - r*dh
        IF (hrk .GE. 0.) THEN
          abs0 = hrk
        ELSE
          abs0 = -hrk
        END IF
        IF (abs0 + ors .GT. 0) THEN
          DO nd=1,nbdirs
            xnhkd(nd) = (2*hrk*hrkd(nd)*(hrk**2+ors*(nu+dk**2))-hrk**2*(
     +        2*hrk*hrkd(nd)+orsd(nd)*(nu+dk**2)+ors*2*dk*dkd(nd)))/(hrk
     +        **2+ors*(nu+dk**2))**2
            xnkhd(nd) = (2*krh*krhd(nd)*(krh**2+ors*(nu+dh**2))-krh**2*(
     +        2*krh*krhd(nd)+orsd(nd)*(nu+dh**2)+ors*2*dh*dhd(nd)))/(krh
     +        **2+ors*(nu+dh**2))**2
          ENDDO
          xnhk = hrk**2/(hrk**2+ors*(nu+dk**2))
          xnkh = krh**2/(krh**2+ors*(nu+dh**2))
        ELSE
          xnhk = 0
          xnkh = 0
          DO nd=1,nbdirsmax
            xnkhd(nd) = 0.D0
          ENDDO
          DO nd=1,nbdirsmax
            xnhkd(nd) = 0.D0
          ENDDO
        END IF
        arg1 = dh - r*dk
        hs = SIGN(one, arg1)
        arg1 = dk - r*dh
        ks = SIGN(one, arg1)
        IF (MOD(nu, 2) .EQ. 0) THEN
          result1 = SQRT(ors)
          arg1 = 16*(nu+dh**2)
          DO nd=1,nbdirs
            IF (ors .EQ. 0.0) THEN
              result1d(nd) = 0.D0
            ELSE
              result1d(nd) = orsd(nd)/(2.0*SQRT(ors))
            END IF
            bvtd(nd) = (rd(nd)*result1-result1d(nd)*r)/(result1**2+(-r)
     +        **2)/tpi
            arg1d(nd) = 16*2*dh*dhd(nd)
            IF (arg1 .EQ. 0.0) THEN
              result1d(nd) = 0.D0
            ELSE
              result1d(nd) = arg1d(nd)/(2.0*SQRT(arg1))
            END IF
            arg1d(nd) = 16*2*dk*dkd(nd)
            result2d(nd) = -(xnkhd(nd)/(2.0*SQRT(1-xnkh)))
          ENDDO
          bvt = ATAN2(result1, -r)/tpi
          result1 = SQRT(arg1)
          arg1 = 16*(nu+dk**2)
          DO nd=1,nbdirs
            gmphd(nd) = (dhd(nd)*result1-dh*result1d(nd))/result1**2
            IF (arg1 .EQ. 0.0) THEN
              result1d(nd) = 0.D0
            ELSE
              result1d(nd) = arg1d(nd)/(2.0*SQRT(arg1))
            END IF
            arg1d(nd) = xnkhd(nd)*(1-xnkh) - xnkh*xnkhd(nd)
          ENDDO
          gmph = dh/result1
          result1 = SQRT(arg1)
          DO nd=1,nbdirs
            gmpkd(nd) = (dkd(nd)*result1-dk*result1d(nd))/result1**2
            IF (xnkh .EQ. 0.0) THEN
              result1d(nd) = 0.D0
            ELSE
              result1d(nd) = xnkhd(nd)/(2.0*SQRT(xnkh))
            END IF
          ENDDO
          gmpk = dk/result1
          result1 = SQRT(xnkh)
          result2 = SQRT(1 - xnkh)
          arg1 = xnkh*(1-xnkh)
          DO nd=1,nbdirs
            btnckhd(nd) = 2*(result1d(nd)*result2-result2d(nd)*result1)/
     +        (result1**2+result2**2)/pi
            IF (arg1 .EQ. 0.0) THEN
              result1d(nd) = 0.D0
            ELSE
              result1d(nd) = arg1d(nd)/(2.0*SQRT(arg1))
            END IF
            btpdkhd(nd) = 2*result1d(nd)/pi
            IF (xnhk .EQ. 0.0) THEN
              result1d(nd) = 0.D0
            ELSE
              result1d(nd) = xnhkd(nd)/(2.0*SQRT(xnhk))
            END IF
            result2d(nd) = -(xnhkd(nd)/(2.0*SQRT(1-xnhk)))
            arg1d(nd) = xnhkd(nd)*(1-xnhk) - xnhk*xnhkd(nd)
          ENDDO
          btnckh = 2*ATAN2(result1, result2)/pi
          result1 = SQRT(arg1)
          btpdkh = 2*result1/pi
          result1 = SQRT(xnhk)
          result2 = SQRT(1 - xnhk)
          arg1 = xnhk*(1-xnhk)
          DO nd=1,nbdirs
            btnchkd(nd) = 2*(result1d(nd)*result2-result2d(nd)*result1)/
     +        (result1**2+result2**2)/pi
            IF (arg1 .EQ. 0.0) THEN
              result1d(nd) = 0.D0
            ELSE
              result1d(nd) = arg1d(nd)/(2.0*SQRT(arg1))
            END IF
            btpdhkd(nd) = 2*result1d(nd)/pi
          ENDDO
          btnchk = 2*ATAN2(result1, result2)/pi
          result1 = SQRT(arg1)
          btpdhk = 2*result1/pi
          DO j=1,nu/2
            DO nd=1,nbdirs
              bvtd(nd) = bvtd(nd) + gmphd(nd)*(1+ks*btnckh) + gmph*ks*
     +          btnckhd(nd)
              bvtd(nd) = bvtd(nd) + gmpkd(nd)*(1+hs*btnchk) + gmpk*hs*
     +          btnchkd(nd)
              btnckhd(nd) = btnckhd(nd) + btpdkhd(nd)
              btpdkhd(nd) = 2*j*(btpdkhd(nd)*(1-xnkh)-btpdkh*xnkhd(nd))/
     +          (2*j+1)
              btnchkd(nd) = btnchkd(nd) + btpdhkd(nd)
              btpdhkd(nd) = 2*j*(btpdhkd(nd)*(1-xnhk)-btpdhk*xnhkd(nd))/
     +          (2*j+1)
              gmphd(nd) = ((2*j-1)*gmphd(nd)*2*j*(1+dh**2/nu)-gmph*(2*j-
     +          1)*2**2*j*dh*dhd(nd)/nu)/(2*j*(1+dh**2/nu))**2
              gmpkd(nd) = ((2*j-1)*gmpkd(nd)*2*j*(1+dk**2/nu)-gmpk*(2*j-
     +          1)*2**2*j*dk*dkd(nd)/nu)/(2*j*(1+dk**2/nu))**2
            ENDDO
            bvt = bvt + gmph*(1+ks*btnckh)
            bvt = bvt + gmpk*(1+hs*btnchk)
            btnckh = btnckh + btpdkh
            btpdkh = 2*j*btpdkh*(1-xnkh)/(2*j+1)
            btnchk = btnchk + btpdhk
            btpdhk = 2*j*btpdhk*(1-xnhk)/(2*j+1)
            gmph = gmph*(2*j-1)/(2*j*(1+dh**2/nu))
            gmpk = gmpk*(2*j-1)/(2*j*(1+dk**2/nu))
          ENDDO
        ELSE
          arg1 = dh**2 + dk**2 - 2*r*dh*dk + nu*ors
          qhrk = SQRT(arg1)
          hkrn = dh*dk + r*nu
          hkn = dh*dk - nu
          hpk = dh + dk
          DO nd=1,nbdirs
            arg1d(nd) = 2*dh*dhd(nd) + 2*dk*dkd(nd) - 2*((rd(nd)*dh+r*
     +        dhd(nd))*dk) - 2*(r*dh*dkd(nd)) + nu*orsd(nd)
            IF (arg1 .EQ. 0.0) THEN
              qhrkd(nd) = 0.D0
            ELSE
              qhrkd(nd) = arg1d(nd)/(2.0*SQRT(arg1))
            END IF
            hkrnd(nd) = dhd(nd)*dk + dh*dkd(nd) + nu*rd(nd)
            hknd(nd) = dhd(nd)*dk + dh*dkd(nd)
            hpkd(nd) = dhd(nd) + dkd(nd)
            arg1d(nd) = -(snu*(hknd(nd)*qhrk+hkn*qhrkd(nd)+hpkd(nd)*hkrn
     +        +hpk*hkrnd(nd)))
            arg2d(nd) = hknd(nd)*hkrn + hkn*hkrnd(nd) - nu*(hpkd(nd)*
     +        qhrk+hpk*qhrkd(nd))
          ENDDO
          arg1 = -(snu*(hkn*qhrk+hpk*hkrn))
          arg2 = hkn*hkrn - nu*hpk*qhrk
          DO nd=1,nbdirs
            bvtd(nd) = (arg1d(nd)*arg2-arg2d(nd)*arg1)/(arg1**2+arg2**2)
     +        /tpi
          ENDDO
          bvt = ATAN2(arg1, arg2)/tpi
          IF (bvt .LT. -eps) bvt = bvt + 1
          DO nd=1,nbdirs
            gmphd(nd) = (dhd(nd)*tpi*snu*(1+dh**2/nu)-dh**2*tpi*snu*2*
     +        dhd(nd)/nu)/(tpi*snu*(1+dh**2/nu))**2
            gmpkd(nd) = (dkd(nd)*tpi*snu*(1+dk**2/nu)-dk**2*tpi*snu*2*
     +        dkd(nd)/nu)/(tpi*snu*(1+dk**2/nu))**2
            IF (xnkh .EQ. 0.0) THEN
              btnckhd(nd) = 0.D0
            ELSE
              btnckhd(nd) = xnkhd(nd)/(2.0*SQRT(xnkh))
            END IF
            btpdkhd(nd) = btnckhd(nd)
            IF (xnhk .EQ. 0.0) THEN
              btnchkd(nd) = 0.D0
            ELSE
              btnchkd(nd) = xnhkd(nd)/(2.0*SQRT(xnhk))
            END IF
            btpdhkd(nd) = btnchkd(nd)
          ENDDO
          gmph = dh/(tpi*snu*(1+dh**2/nu))
          gmpk = dk/(tpi*snu*(1+dk**2/nu))
          btnckh = SQRT(xnkh)
          btpdkh = btnckh
          btnchk = SQRT(xnhk)
          btpdhk = btnchk
          DO j=1,(nu-1)/2
            DO nd=1,nbdirs
              bvtd(nd) = bvtd(nd) + gmphd(nd)*(1+ks*btnckh) + gmph*ks*
     +          btnckhd(nd)
              bvtd(nd) = bvtd(nd) + gmpkd(nd)*(1+hs*btnchk) + gmpk*hs*
     +          btnchkd(nd)
              btpdkhd(nd) = (2*j-1)*(btpdkhd(nd)*(1-xnkh)-btpdkh*xnkhd(
     +          nd))/(2*j)
              btnckhd(nd) = btnckhd(nd) + btpdkhd(nd)
              btpdhkd(nd) = (2*j-1)*(btpdhkd(nd)*(1-xnhk)-btpdhk*xnhkd(
     +          nd))/(2*j)
              btnchkd(nd) = btnchkd(nd) + btpdhkd(nd)
              gmphd(nd) = (2*j*gmphd(nd)*(2*j+1)*(1+dh**2/nu)-2**2*j*
     +          gmph*(2*j+1)*dh*dhd(nd)/nu)/((2*j+1)*(1+dh**2/nu))**2
              gmpkd(nd) = (2*j*gmpkd(nd)*(2*j+1)*(1+dk**2/nu)-2**2*j*
     +          gmpk*(2*j+1)*dk*dkd(nd)/nu)/((2*j+1)*(1+dk**2/nu))**2
            ENDDO
            bvt = bvt + gmph*(1+ks*btnckh)
            bvt = bvt + gmpk*(1+hs*btnchk)
            btpdkh = (2*j-1)*btpdkh*(1-xnkh)/(2*j)
            btnckh = btnckh + btpdkh
            btpdhk = (2*j-1)*btpdhk*(1-xnhk)/(2*j)
            btnchk = btnchk + btpdhk
            gmph = 2*j*gmph/((2*j+1)*(1+dh**2/nu))
            gmpk = 2*j*gmpk/((2*j+1)*(1+dk**2/nu))
          ENDDO
        END IF
        DO nd=1,nbdirs
          bvtld(nd) = bvtd(nd)
        ENDDO
        bvtl = bvt
      END IF
      END

C  Differentiation of studnt in forward (tangent) mode (with options multiDirectional i4 dr8 r4):
C   variations   of useful results: studnt
C   with respect to varying inputs: t
C
      SUBROUTINE STUDNT_DV(nu, t, td, studnt, studntd, nbdirs)
      USE diffsizes
      IMPLICIT NONE
C  Hint: nbdirsmax should be the maximum number of differentiation directions
C
C     Student t Distribution Function
C
C                       T
C         STUDNT = C   I  ( 1 + y*y/NU )**( -(NU+1)/2 ) dy
C                   NU -INF
C
      INTEGER nu, j
      DOUBLE PRECISION t, zro, one, pi, PHID
      DOUBLE PRECISION td(nbdirsmax)
      DOUBLE PRECISION cssthe, snthe, polyn, tt, ts, rn
      DOUBLE PRECISION cssthed(nbdirsmax), snthed(nbdirsmax), polynd(
     +                 nbdirsmax), ttd(nbdirsmax), tsd(nbdirsmax)
      PARAMETER (zro=0, one=1)
      INTRINSIC ACOS
      INTRINSIC ATAN
      INTRINSIC SQRT
      INTRINSIC MOD
      INTRINSIC MIN
      INTRINSIC MAX
      DOUBLE PRECISION y1
      DOUBLE PRECISION y1d(nbdirsmax)
      DOUBLE PRECISION arg1
      DOUBLE PRECISION arg1d(nbdirsmax)
      DOUBLE PRECISION result1
      DOUBLE PRECISION result1d(nbdirsmax)
      INTEGER nd
      DOUBLE PRECISION studnt
      DOUBLE PRECISION studntd(nbdirsmax)
      INTEGER nbdirs
      pi = ACOS(-one)
      IF (nu .LT. 1) THEN
        CALL PHID_DV(t, td, studnt, studntd, nbdirs)
      ELSE IF (nu .EQ. 1) THEN
        DO nd=1,nbdirs
          studntd(nd) = 2*td(nd)/(1.0+t**2)/pi/2
        ENDDO
        studnt = (1+2*ATAN(t)/pi)/2
      ELSE IF (nu .EQ. 2) THEN
        arg1 = 2 + t*t
        result1 = SQRT(arg1)
        DO nd=1,nbdirs
          arg1d(nd) = td(nd)*t + t*td(nd)
          IF (arg1 .EQ. 0.0) THEN
            result1d(nd) = 0.D0
          ELSE
            result1d(nd) = arg1d(nd)/(2.0*SQRT(arg1))
          END IF
          studntd(nd) = (td(nd)*result1-t*result1d(nd))/result1**2/2
        ENDDO
        studnt = (1+t/result1)/2
      ELSE
        tt = t*t
        DO nd=1,nbdirs
          ttd(nd) = td(nd)*t + t*td(nd)
          cssthed(nd) = (-(ttd(nd)/nu))/(1+tt/nu)**2
        ENDDO
        cssthe = 1/(1+tt/nu)
        polyn = 1
        DO nd=1,nbdirsmax
          polynd(nd) = 0.D0
        ENDDO
        DO j=nu-2,2,-2
          DO nd=1,nbdirs
            polynd(nd) = (j-1)*(cssthed(nd)*polyn+cssthe*polynd(nd))/j
          ENDDO
          polyn = 1 + (j-1)*cssthe*polyn/j
        ENDDO
        IF (MOD(nu, 2) .EQ. 1) THEN
          rn = nu
          result1 = SQRT(rn)
          ts = t/result1
          DO nd=1,nbdirs
            tsd(nd) = td(nd)/result1
            studntd(nd) = 2*(tsd(nd)/(1.0+ts**2)+(tsd(nd)*cssthe+ts*
     +        cssthed(nd))*polyn+ts*cssthe*polynd(nd))/pi/2
          ENDDO
          studnt = (1+2*(ATAN(ts)+ts*cssthe*polyn)/pi)/2
        ELSE
          arg1 = nu + tt
          result1 = SQRT(arg1)
          snthe = t/result1
          DO nd=1,nbdirs
            arg1d(nd) = ttd(nd)
            IF (arg1 .EQ. 0.0) THEN
              result1d(nd) = 0.D0
            ELSE
              result1d(nd) = arg1d(nd)/(2.0*SQRT(arg1))
            END IF
            snthed(nd) = (td(nd)*result1-t*result1d(nd))/result1**2
            studntd(nd) = (snthed(nd)*polyn+snthe*polynd(nd))/2
          ENDDO
          studnt = (1+snthe*polyn)/2
        END IF
        IF (studnt .GT. one) THEN
          y1 = one
          DO nd=1,nbdirsmax
            y1d(nd) = 0.D0
          ENDDO
        ELSE
          DO nd=1,nbdirs
            y1d(nd) = studntd(nd)
          ENDDO
          y1 = studnt
        END IF
        IF (zro .LT. y1) THEN
          DO nd=1,nbdirs
            studntd(nd) = y1d(nd)
          ENDDO
          studnt = y1
        ELSE
          studnt = zro
          DO nd=1,nbdirsmax
            studntd(nd) = 0.D0
          ENDDO
        END IF
      END IF
      END

C  Differentiation of bvnd in forward (tangent) mode (with options multiDirectional i4 dr8 r4):
C   variations   of useful results: bvnd
C   with respect to varying inputs: dh dk r
C
      SUBROUTINE BVND_DV(dh, dhd, dk, dkd, r, rd, bvnd, bvndd, nbdirs)
      USE diffsizes
      IMPLICIT NONE
C  Hint: nbdirsmax should be the maximum number of differentiation directions
C
C     A function for computing bivariate normal probabilities.
C
C       Alan Genz
C       Department of Mathematics
C       Washington State University
C       Pullman, WA 99164-3113
C       Email : alangenz@wsu.edu
C
C    This function is based on the method described by 
C        Drezner, Z and G.O. Wesolowsky, (1989),
C        On the computation of the bivariate normal integral,
C        Journal of Statist. Comput. Simul. 35, pp. 101-107,
C    with major modifications for double precision, and for |R| close to 1.
C
C BVND calculates the probability that X > DH and Y > DK.
C      Note: Prob( X < DH, Y < DK ) = BVND( -DH, -DK, R ).
C
C Parameters
C
C   DH  DOUBLE PRECISION, integration limit
C   DK  DOUBLE PRECISION, integration limit
C   R   DOUBLE PRECISION, correlation coefficient
C
      DOUBLE PRECISION dh, dk, r, twopi
      DOUBLE PRECISION dhd(nbdirsmax), dkd(nbdirsmax), rd(nbdirsmax)
      INTEGER i, is, lg, ng
      PARAMETER (twopi=6.283185307179586d0)
      DOUBLE PRECISION x(10, 3), w(10, 3), as, a, b, c, d, rs, xs, bvn
      DOUBLE PRECISION asd(nbdirsmax), ad(nbdirsmax), bd(nbdirsmax), cd(
     +                 nbdirsmax), dd(nbdirsmax), rsd(nbdirsmax), xsd(
     +                 nbdirsmax), bvnd0(nbdirsmax)
      DOUBLE PRECISION PHID, sn, asr, h, k, bs, hs, hk
      DOUBLE PRECISION snd(nbdirsmax), asrd(nbdirsmax), hd(nbdirsmax), 
     +                 kd(nbdirsmax), bsd(nbdirsmax), hsd(nbdirsmax), 
     +                 hkd(nbdirsmax)
      SAVE x, w
      INTRINSIC ABS
      INTRINSIC ASIN
      INTRINSIC SIN
      INTRINSIC EXP
      INTRINSIC SQRT
      INTRINSIC MAX
      DOUBLE PRECISION abs0
      DOUBLE PRECISION abs1
      DOUBLE PRECISION abs2
      DOUBLE PRECISION abs3
      DOUBLE PRECISION abs4
      DOUBLE PRECISION max1
      DOUBLE PRECISION max1d(nbdirsmax)
      DOUBLE PRECISION arg1
      DOUBLE PRECISION arg1d(nbdirsmax)
      DOUBLE PRECISION result1
      DOUBLE PRECISION result1d(nbdirsmax)
      DOUBLE PRECISION result2
      DOUBLE PRECISION result2d(nbdirsmax)
      DOUBLE PRECISION arg2
      DOUBLE PRECISION arg2d(nbdirsmax)
      INTEGER nd
      DOUBLE PRECISION bvndd(nbdirsmax)
      DOUBLE PRECISION bvnd
      INTEGER nbdirs
C     Gauss Legendre Points and Weights, N =  6
      DATA (w(i, 1), x(i, 1), i=1,3) /0.1713244923791705d+00, -
     +     0.9324695142031522d+00, 0.3607615730481384d+00, -
     +     0.6612093864662647d+00, 0.4679139345726904d+00, -
     +     0.2386191860831970d+00/
C     Gauss Legendre Points and Weights, N = 12
      DATA (w(i, 2), x(i, 2), i=1,6) /0.4717533638651177d-01, -
     +     0.9815606342467191d+00, 0.1069393259953183d+00, -
     +     0.9041172563704750d+00, 0.1600783285433464d+00, -
     +     0.7699026741943050d+00, 0.2031674267230659d+00, -
     +     0.5873179542866171d+00, 0.2334925365383547d+00, -
     +     0.3678314989981802d+00, 0.2491470458134029d+00, -
     +     0.1252334085114692d+00/
C     Gauss Legendre Points and Weights, N = 20
      DATA (w(i, 3), x(i, 3), i=1,10) /0.1761400713915212d-01, -
     +     0.9931285991850949d+00, 0.4060142980038694d-01, -
     +     0.9639719272779138d+00, 0.6267204833410906d-01, -
     +     0.9122344282513259d+00, 0.8327674157670475d-01, -
     +     0.8391169718222188d+00, 0.1019301198172404d+00, -
     +     0.7463319064601508d+00, 0.1181945319615184d+00, -
     +     0.6360536807265150d+00, 0.1316886384491766d+00, -
     +     0.5108670019508271d+00, 0.1420961093183821d+00, -
     +     0.3737060887154196d+00, 0.1491729864726037d+00, -
     +     0.2277858511416451d+00, 0.1527533871307259d+00, -
     +     0.7652652113349733d-01/
      IF (r .GE. 0.) THEN
        abs0 = r
      ELSE
        abs0 = -r
      END IF
      IF (abs0 .LT. 0.3) THEN
        ng = 1
        lg = 3
      ELSE
        IF (r .GE. 0.) THEN
          abs1 = r
        ELSE
          abs1 = -r
        END IF
        IF (abs1 .LT. 0.75) THEN
          ng = 2
          lg = 6
        ELSE
          ng = 3
          lg = 10
        END IF
      END IF
      h = dh
      k = dk
      DO nd=1,nbdirs
        hd(nd) = dhd(nd)
        kd(nd) = dkd(nd)
        hkd(nd) = hd(nd)*k + h*kd(nd)
      ENDDO
      hk = h*k
      bvn = 0
      IF (r .GE. 0.) THEN
        abs2 = r
      ELSE
        abs2 = -r
      END IF
      IF (abs2 .LT. 0.925) THEN
        IF (r .GE. 0.) THEN
          abs3 = r
        ELSE
          abs3 = -r
        END IF
        IF (abs3 .GT. 0) THEN
          DO nd=1,nbdirs
            hsd(nd) = (hd(nd)*h+h*hd(nd)+kd(nd)*k+k*kd(nd))/2
            IF (r .EQ. 1.0 .OR. r .EQ. (-1.0)) THEN
              asrd(nd) = 0.D0
            ELSE
              asrd(nd) = rd(nd)/SQRT(1.0-r**2)
            END IF
          ENDDO
          hs = (h*h+k*k)/2
          asr = ASIN(r)
          DO nd=1,nbdirsmax
            bvnd0(nd) = 0.D0
          ENDDO
          DO i=1,lg
            DO is=-1,1,2
              arg1 = asr*(is*x(i, ng)+1)/2
              sn = SIN(arg1)
              DO nd=1,nbdirs
                arg1d(nd) = (is*x(i, ng)+1)*asrd(nd)/2
                snd(nd) = arg1d(nd)*COS(arg1)
                arg1d(nd) = ((snd(nd)*hk+sn*hkd(nd)-hsd(nd))*(1-sn*sn)-(
     +            sn*hk-hs)*(-(snd(nd)*sn)-sn*snd(nd)))/(1-sn*sn)**2
              ENDDO
              arg1 = (sn*hk-hs)/(1-sn*sn)
              DO nd=1,nbdirs
                bvnd0(nd) = bvnd0(nd) + w(i, ng)*arg1d(nd)*EXP(arg1)
              ENDDO
              bvn = bvn + w(i, ng)*EXP(arg1)
            ENDDO
          ENDDO
          DO nd=1,nbdirs
            bvnd0(nd) = (bvnd0(nd)*asr+bvn*asrd(nd))/(2*twopi)
          ENDDO
          bvn = bvn*asr/(2*twopi)
        ELSE
          DO nd=1,nbdirsmax
            bvnd0(nd) = 0.D0
          ENDDO
        END IF
        CALL PHID_DV(-h, -hd, result1, result1d, nbdirs)
        CALL PHID_DV(-k, -kd, result2, result2d, nbdirs)
        DO nd=1,nbdirs
          bvnd0(nd) = bvnd0(nd) + result1d(nd)*result2 + result1*
     +      result2d(nd)
        ENDDO
        bvn = bvn + result1*result2
      ELSE
        IF (r .LT. 0) THEN
          DO nd=1,nbdirs
            kd(nd) = -kd(nd)
            hkd(nd) = -hkd(nd)
          ENDDO
          k = -k
          hk = -hk
        END IF
        IF (r .GE. 0.) THEN
          abs4 = r
        ELSE
          abs4 = -r
        END IF
        IF (abs4 .LT. 1) THEN
          as = (1-r)*(1+r)
          bs = (h-k)**2
          DO nd=1,nbdirs
            asd(nd) = (1-r)*rd(nd) - rd(nd)*(1+r)
            IF (as .EQ. 0.0) THEN
              ad(nd) = 0.D0
            ELSE
              ad(nd) = asd(nd)/(2.0*SQRT(as))
            END IF
            bsd(nd) = 2*(h-k)*(hd(nd)-kd(nd))
            cd(nd) = (-hkd(nd))/8
            dd(nd) = (-hkd(nd))/16
            asrd(nd) = -(((bsd(nd)*as-bs*asd(nd))/as**2+hkd(nd))/2)
          ENDDO
          a = SQRT(as)
          c = (4-hk)/8
          d = (12-hk)/16
          asr = -((bs/as+hk)/2)
          IF (asr .GT. -100) THEN
            DO nd=1,nbdirs
              bvnd0(nd) = (ad(nd)*EXP(asr)+a*asrd(nd)*EXP(asr))*(1-c*(bs
     +          -as)*(1-d*bs/5)/3+c*d*as*as/5) + a*EXP(asr)*(((cd(nd)*d+
     +          c*dd(nd))*as**2+c*d*(asd(nd)*as+as*asd(nd)))/5-((cd(nd)*
     +          (bs-as)+c*(bsd(nd)-asd(nd)))*(1-d*bs/5)-c*(bs-as)*(dd(nd
     +          )*bs+d*bsd(nd))/5)/3)
            ENDDO
            bvn = a*EXP(asr)*(1-c*(bs-as)*(1-d*bs/5)/3+c*d*as*as/5)
          ELSE
            DO nd=1,nbdirsmax
              bvnd0(nd) = 0.D0
            ENDDO
          END IF
          IF (-hk .LT. 100) THEN
            b = SQRT(bs)
            DO nd=1,nbdirs
              IF (bs .EQ. 0.0) THEN
                bd(nd) = 0.D0
              ELSE
                bd(nd) = bsd(nd)/(2.0*SQRT(bs))
              END IF
              arg1d(nd) = -(hkd(nd)/2)
              arg2d(nd) = -((bd(nd)*a-b*ad(nd))/a**2)
            ENDDO
            arg1 = -(hk/2)
            result1 = SQRT(twopi)
            arg2 = -(b/a)
            CALL PHID_DV(arg2, arg2d, result2, result2d, nbdirs)
            DO nd=1,nbdirs
              bvnd0(nd) = bvnd0(nd) - result1*((arg1d(nd)*EXP(arg1)*
     +          result2*b+EXP(arg1)*(result2d(nd)*b+result2*bd(nd)))*(1-
     +          c*bs*(1-d*bs/5)/3)-EXP(arg1)*result2*b*((cd(nd)*bs+c*bsd
     +          (nd))*(1-d*bs/5)-c*bs*(dd(nd)*bs+d*bsd(nd))/5)/3)
            ENDDO
            bvn = bvn - EXP(arg1)*result1*result2*b*(1-c*bs*(1-d*bs/5)/3
     +        )
          END IF
          DO nd=1,nbdirs
            ad(nd) = ad(nd)/2
          ENDDO
          a = a/2
          DO i=1,lg
            DO is=-1,1,2
              xs = (a*(is*x(i, ng)+1))**2
              DO nd=1,nbdirs
                xsd(nd) = 2*a*(is*x(i, ng)+1)**2*ad(nd)
                rsd(nd) = -(xsd(nd)/(2.0*SQRT(1-xs)))
                asrd(nd) = -(((bsd(nd)*xs-bs*xsd(nd))/xs**2+hkd(nd))/2)
              ENDDO
              rs = SQRT(1 - xs)
              asr = -((bs/xs+hk)/2)
              IF (asr .GT. -100) THEN
                arg1 = -(hk*xs/(2*(1+rs)**2))
                DO nd=1,nbdirs
                  arg1d(nd) = -(((hkd(nd)*xs+hk*xsd(nd))*2*(1+rs)**2-hk*
     +              xs*2**2*(1+rs)*rsd(nd))/(2*(1+rs)**2)**2)
                  bvnd0(nd) = bvnd0(nd) + w(i, ng)*((ad(nd)*EXP(asr)+a*
     +              asrd(nd)*EXP(asr))*(EXP(arg1)/rs-(1+c*xs*(1+d*xs)))+
     +              a*EXP(asr)*((arg1d(nd)*EXP(arg1)*rs-EXP(arg1)*rsd(nd
     +              ))/rs**2-(cd(nd)*xs+c*xsd(nd))*(1+d*xs)-c*xs*(dd(nd)
     +              *xs+d*xsd(nd))))
                ENDDO
                bvn = bvn + a*w(i, ng)*EXP(asr)*(EXP(arg1)/rs-(1+c*xs*(1
     +            +d*xs)))
              END IF
            ENDDO
          ENDDO
          DO nd=1,nbdirs
            bvnd0(nd) = -(bvnd0(nd)/twopi)
          ENDDO
          bvn = -(bvn/twopi)
        ELSE
          DO nd=1,nbdirsmax
            bvnd0(nd) = 0.D0
          ENDDO
        END IF
        IF (r .GT. 0) THEN
          IF (h .LT. k) THEN
            DO nd=1,nbdirs
              max1d(nd) = kd(nd)
            ENDDO
            max1 = k
          ELSE
            DO nd=1,nbdirs
              max1d(nd) = hd(nd)
            ENDDO
            max1 = h
          END IF
          CALL PHID_DV(-max1, -max1d, result1, result1d, nbdirs)
          DO nd=1,nbdirs
            bvnd0(nd) = bvnd0(nd) + result1d(nd)
          ENDDO
          bvn = bvn + result1
        ELSE
          DO nd=1,nbdirs
            bvnd0(nd) = -bvnd0(nd)
          ENDDO
          bvn = -bvn
          IF (k .GT. h) THEN
            IF (h .LT. 0) THEN
              CALL PHID_DV(k, kd, result1, result1d, nbdirs)
              CALL PHID_DV(h, hd, result2, result2d, nbdirs)
              DO nd=1,nbdirs
                bvnd0(nd) = bvnd0(nd) + result1d(nd) - result2d(nd)
              ENDDO
              bvn = bvn + result1 - result2
            ELSE
              CALL PHID_DV(-h, -hd, result1, result1d, nbdirs)
              CALL PHID_DV(-k, -kd, result2, result2d, nbdirs)
              DO nd=1,nbdirs
                bvnd0(nd) = bvnd0(nd) + result1d(nd) - result2d(nd)
              ENDDO
              bvn = bvn + result1 - result2
            END IF
          END IF
        END IF
      END IF
      DO nd=1,nbdirs
        bvndd(nd) = bvnd0(nd)
      ENDDO
      bvnd = bvn
      END
C
C

C  Differentiation of phid in forward (tangent) mode (with options multiDirectional i4 dr8 r4):
C   variations   of useful results: phid
C   with respect to varying inputs: z
C
      SUBROUTINE PHID_DV(z, zd, phid, phidd, nbdirs)
      USE diffsizes
      IMPLICIT NONE
C  Hint: nbdirsmax should be the maximum number of differentiation directions
C     
C     Normal distribution probabilities accurate to 1d-15.
C     Reference: J.L. Schonfelder, Math Comp 32(1978), pp 1232-1240. 
C     
      INTEGER i, im
      DOUBLE PRECISION a(0:43), bm, b, bp, p, rtwo, t, xa, z
      DOUBLE PRECISION bmd(nbdirsmax), bd(nbdirsmax), bpd(nbdirsmax), pd
     +                 (nbdirsmax), td(nbdirsmax), xad(nbdirsmax), zd(
     +                 nbdirsmax)
      PARAMETER (rtwo=1.414213562373095048801688724209d0, im=24)
      SAVE a
      INTRINSIC ABS
      INTRINSIC EXP
      DOUBLE PRECISION abs0
      DOUBLE PRECISION abs0d(nbdirsmax)
      DOUBLE PRECISION arg1
      DOUBLE PRECISION arg1d(nbdirsmax)
      INTEGER nd
      DOUBLE PRECISION phidd(nbdirsmax)
      DOUBLE PRECISION phid
      INTEGER nbdirs
      DATA (a(i), i=0,43) /6.10143081923200417926465815756d-1, -
     +     4.34841272712577471828182820888d-1, 
     +     1.76351193643605501125840298123d-1, -
     +     6.0710795609249414860051215825d-2, 
     +     1.7712068995694114486147141191d-2, -
     +     4.321119385567293818599864968d-3, 
     +     8.54216676887098678819832055d-4, -
     +     1.27155090609162742628893940d-4, 
     +     1.1248167243671189468847072d-5, 3.13063885421820972630152d-7
     +     , -2.70988068537762022009086d-7, 3.0737622701407688440959d-8
     +     , 2.515620384817622937314d-9, -1.028929921320319127590d-9, 
     +     2.9944052119949939363d-11, 2.6051789687266936290d-11, -
     +     2.634839924171969386d-12, -6.43404509890636443d-13, 
     +     1.12457401801663447d-13, 1.7281533389986098d-14, -
     +     4.264101694942375d-15, -5.45371977880191d-16, 
     +     1.58697607761671d-16, 2.0899837844334d-17, -
     +     5.900526869409d-18, -9.41893387554d-19, 2.14977356470d-19, 
     +     4.6660985008d-20, -7.243011862d-21, -2.387966824d-21, 
     +     1.91177535d-22, 1.20482568d-22, -6.72377d-25, -5.747997d-24, 
     +     -4.28493d-25, 2.44856d-25, 4.3793d-26, -8.151d-27, -3.089d-27
     +     , 9.3d-29, 1.74d-28, 1.6d-29, -8.0d-30, -2.0d-30/
      IF (z .GE. 0.) THEN
        DO nd=1,nbdirs
          abs0d(nd) = zd(nd)
        ENDDO
        abs0 = z
      ELSE
        DO nd=1,nbdirs
          abs0d(nd) = -zd(nd)
        ENDDO
        abs0 = -z
      END IF
      DO nd=1,nbdirs
C     
        xad(nd) = abs0d(nd)/rtwo
      ENDDO
      xa = abs0/rtwo
      IF (xa .GT. 100) THEN
        p = 0
        DO nd=1,nbdirsmax
          pd(nd) = 0.D0
        ENDDO
      ELSE
        DO nd=1,nbdirs
          td(nd) = (8*xad(nd)*(4*xa+15)-(8*xa-30)*4*xad(nd))/(4*xa+15)**
     +      2
        ENDDO
        t = (8*xa-30)/(4*xa+15)
        bm = 0
        b = 0
        DO nd=1,nbdirsmax
          bmd(nd) = 0.D0
        ENDDO
        DO nd=1,nbdirsmax
          bpd(nd) = 0.D0
        ENDDO
        DO nd=1,nbdirsmax
          bd(nd) = 0.D0
        ENDDO
        DO i=im,0,-1
          bp = b
          b = bm
          DO nd=1,nbdirs
            bpd(nd) = bd(nd)
            bd(nd) = bmd(nd)
            bmd(nd) = td(nd)*b + t*bd(nd) - bpd(nd)
          ENDDO
          bm = t*b - bp + a(i)
        ENDDO
        arg1 = -(xa*xa)
        DO nd=1,nbdirs
          arg1d(nd) = -(xad(nd)*xa+xa*xad(nd))
          pd(nd) = (arg1d(nd)*EXP(arg1)*(bm-bp)+EXP(arg1)*(bmd(nd)-bpd(
     +      nd)))/4
        ENDDO
        p = EXP(arg1)*(bm-bp)/4
      END IF
      IF (z .GT. 0) THEN
        DO nd=1,nbdirs
          pd(nd) = -pd(nd)
        ENDDO
        p = 1 - p
      END IF
      DO nd=1,nbdirs
        phidd(nd) = pd(nd)
      ENDDO
      phid = p
      END

